<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Stewart Platform Control — Pingpong via Stewart.Animation</title>
    <style>
        :root {
            --bg-0: #1e1e1e;
            --bg-1: #2c2c2c;
            --bg-2: #111111;
            --fg: #f0f0f0;
            --muted: #b8b8b8;
            --accent: #ffcc00;
            --btn: #444;
            --btn-br: #666;
            --btn-hover: #555;
            --panel-shadow: 0 0 10px rgba(0, 0, 0, .5);
            --panel-radius: 10px;
            --row-gap: 12px;
            --pad: 14px;
            --x: #c0392b;
            --x-br: #e74c3c;
            --x-hover: #a93226;
            --y: #1e8449;
            --y-br: #27ae60;
            --y-hover: #196f3d;
            --z: #21618c;
            --z-br: #3498db;
            --z-hover: #1b4f72;
            --ok: #1e8449;
            --bad: #c0392b;
            --off: #777
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: var(--bg-0);
            color: var(--fg);
            display: flex;
            gap: 20px;
            padding: 20px;
            align-items: flex-start;
            justify-content: center
        }

        .panel {
            min-width: 300px;
            background: var(--bg-1);
            padding: var(--pad);
            border-radius: var(--panel-radius);
            box-shadow: var(--panel-shadow);
            display: flex;
            flex-direction: column;
            gap: var(--row-gap)
        }

        h3 {
            margin: 0 0 4px 0;
            color: var(--accent);
            font-size: 16px;
            letter-spacing: .2px
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px
        }

        .axis {
            background: rgba(255, 255, 255, .03);
            border: 1px solid rgba(255, 255, 255, .06);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px
        }

        .row {
            display: grid;
            grid-template-columns: 46px 1fr 46px;
            gap: 10px;
            align-items: center
        }

        .subrow {
            display: grid;
            grid-template-columns: 70px 1fr;
            gap: 10px;
            align-items: center
        }

        .lrow {
            display: grid;
            grid-template-columns: 1fr 1fr 70px 70px;
            gap: 10px;
            align-items: center
        }

        .lrow label {
            color: var(--muted);
            font-size: 12px
        }

        .vrow {
            display: flex;
            flex-direction: column;
            gap: 6px
        }

        button {
            background: var(--btn);
            border: 1px solid var(--btn-br);
            color: var(--fg);
            border-radius: 8px;
            padding: 8px 10px;
            cursor: pointer;
            font-weight: 600
        }

        button:hover {
            background: var(--btn-hover)
        }

        .mini {
            padding: 6px 0;
            font-weight: 700
        }

        .btn-x {
            background: var(--x);
            border-color: var(--x-br)
        }

        .btn-x:hover {
            background: var(--x-hover)
        }

        .btn-y {
            background: var(--y);
            border-color: var(--y-br)
        }

        .btn-y:hover {
            background: var(--y-hover)
        }

        .btn-z {
            background: var(--z);
            border-color: var(--z-br)
        }

        .btn-z:hover {
            background: var(--z-hover)
        }

        .num {
            width: 56px;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid #555;
            background: #1b1b1b;
            color: var(--fg);
            text-align: center;
            font-variant-numeric: tabular-nums
        }

        input[type="number"] {
            width: 100%;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #555;
            background: #1b1b1b;
            color: var(--fg)
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent)
        }

        select,
        input[type="checkbox"] {
            cursor: pointer
        }

        #canvas {
            flex-shrink: 0;
            width: 750px;
            height: 750px;
            background: var(--bg-2);
            border: 2px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, .7)
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 8px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .08);
            background: rgba(255, 255, 255, .03);
            width: max-content
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--ok);
            box-shadow: 0 0 8px rgba(0, 0, 0, .4) inset
        }

        .status.bad .dot {
            background: var(--bad)
        }

        .status span {
            color: #e9e9e9
        }

        .blocked {
            animation: blocked 250ms ease-out
        }

        @keyframes blocked {
            0% {
                box-shadow: 0 0 0 0 rgba(192, 57, 43, .8)
            }

            100% {
                box-shadow: 0 0 0 6px rgba(192, 57, 43, 0)
            }
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 999px;
            background: #202020;
            border: 1px solid #444;
            font-size: 12px
        }

        .pill .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--off)
        }

        .pill.playing .led {
            background: var(--ok)
        }

        .inline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px
        }

        .muted {
            color: var(--muted);
            font-size: 12px
        }
    </style>
</head>

<body>

    <!-- Left: Mechanical, View, Safety & Animation Controls -->
    <section class="panel" id="controls-left">
        <h3>Mechanical</h3>
        <div class="lrow"><label for="rodLengthSlider">Rod Length (mm)</label><input type="range" id="rodLengthSlider"
                min="50" max="300" value="130"><input class="num" type="number" id="rodLengthInput" min="50" max="300"
                value="130"><button id="rodLengthReset">Reset</button></div>
        <div class="lrow"><label for="hornLengthSlider">Horn Length (mm)</label><input type="range"
                id="hornLengthSlider" min="10" max="100" value="50"><input class="num" type="number"
                id="hornLengthInput" min="10" max="100" value="50"><button id="hornLengthReset">Reset</button></div>
        <div class="lrow"><label for="baseRadiusSlider">Base Radius (mm)</label><input type="range"
                id="baseRadiusSlider" min="50" max="200" value="80"><input class="num" type="number"
                id="baseRadiusInput" min="50" max="200" value="80"><button id="baseRadiusReset">Reset</button></div>
        <div class="lrow"><label for="platformRadiusSlider">Platform Radius (mm)</label><input type="range"
                id="platformRadiusSlider" min="30" max="150" value="50"><input class="num" type="number"
                id="platformRadiusInput" min="30" max="150" value="50"><button id="platformRadiusReset">Reset</button>
        </div>
        <div class="lrow"><label for="anchorDistanceSlider">Anker Distance (mm)</label><input type="range"
                id="anchorDistanceSlider" min="0" max="120" value="40"><input class="num" type="number"
                id="anchorDistanceInput" min="0" max="120" value="40"><button id="anchorDistanceReset">Reset</button>
        </div>
        <div class="lrow"><label for="shaftDistanceSlider">Shaft Distance (mm)</label><input type="range"
                id="shaftDistanceSlider" min="0" max="120" value="30"><input class="num" type="number"
                id="shaftDistanceInput" min="0" max="120" value="30"><button id="shaftDistanceReset">Reset</button>
        </div>

        <div class="vrow">
            <label><input type="checkbox" id="platformTurnCheckbox" checked> Platform Turn</label>
            <label><input type="checkbox" id="hornDirCheckbox"> Horn Direction</label>
        </div>

        <div class="vrow">
            <label class="inline"><span>Servo Angle Range (°)</span><span class="muted">min / max</span></label>
            <div style="display:flex; gap:8px; align-items:center;">
                <input class="num" id="servoMinInput" type="number" step="1" value="-90"
                    aria-label="Servo min (degrees)">
                <span class="muted">to</span>
                <input class="num" id="servoMaxInput" type="number" step="1" value="90"
                    aria-label="Servo max (degrees)">
                <button id="servoRangeReset">Reset</button>
            </div>
        </div>

        <h3>View</h3>
        <div class="lrow"><label for="viewXSlider">View X (°)</label><input type="range" id="viewXSlider" min="-180"
                max="180" value="90" step="1"><input class="num" type="number" id="viewXInput" min="-180" max="180"
                value="90"><button id="viewXReset">Reset</button></div>
        <div class="lrow"><label for="viewYSlider">View Y (°)</label><input type="range" id="viewYSlider" min="-180"
                max="180" value="0" step="1"><input class="num" type="number" id="viewYInput" min="-180" max="180"
                value="0"><button id="viewYReset">Reset</button></div>
        <div class="lrow"><label for="viewZSlider">View Z (°)</label><input type="range" id="viewZSlider" min="-180"
                max="180" value="0" step="1"><input class="num" type="number" id="viewZInput" min="-180" max="180"
                value="0"><button id="viewZReset">Reset</button></div>

        <h3>Safety</h3>
        <div class="vrow">
            <label><input type="checkbox" id="ikClampCheckbox" checked> Enforce Valid Kinematics</label>
            <label><input type="checkbox" id="ikClampAnimCheckbox" checked> Enforce on Animations</label>
            <div id="ikStatus" class="status" role="status" aria-live="polite" title="IK: OK">
                <div class="dot"></div><span>IK: OK</span>
            </div>
        </div>

        <div class="section-header">
            <h3 style="margin:0;">Animation</h3>
            <button id="animToggle" class="pill" aria-pressed="false" title="Play/Pause (Space)"><span
                    class="led"></span><span class="label">Play</span></button>
        </div>

        <div class="vrow">
            <label class="inline" for="animationSpeedSlider"><span>Speed</span><span id="speedVal"
                    class="muted">100%</span></label>
            <input type="range" id="animationSpeedSlider" min="10" max="300" step="5" value="100"
                aria-label="Animation speed percent">
        </div>

        <div class="vrow">
            <label for="animationPatternSelect">Pattern</label>
            <select id="animationPatternSelect">
                <option value="none">None</option>
                <option value="wobble">Wobble</option>
                <option value="pingpong">Pingpong</option>
                <option value="rotate">Rotate</option>
                <option value="tilt">Tilt</option>
                <option value="helical">Helical Sweep</option>
                <option value="mouse">Mouse Follow</option>
                <option value="gamepad">Gamepad</option>
            </select>
        </div>
    </section>

    <!-- Center: Canvas -->
    <div id="canvas"></div>

    <!-- Right: Translation & Rotation Controls -->
    <section class="panel" id="controls-right">
        <h3>Translation</h3>
        <div class="axis" data-axis="x" data-type="t">
            <div class="row"><button class="mini btn-x" id="xMinus">X-</button><input type="range" id="xSlider"
                    min="-200" max="200" value="0" step="1"><button class="mini btn-x" id="xPlus">X+</button></div>
            <div class="subrow"><button id="xReset">Reset</button><input type="number" id="xInput" min="-200" max="200"
                    step="1" value="0"></div>
        </div>
        <div class="axis" data-axis="y" data-type="t">
            <div class="row"><button class="mini btn-y" id="yMinus">Y-</button><input type="range" id="ySlider"
                    min="-200" max="200" value="0" step="1"><button class="mini btn-y" id="yPlus">Y+</button></div>
            <div class="subrow"><button id="yReset">Reset</button><input type="number" id="yInput" min="-200" max="200"
                    step="1" value="0"></div>
        </div>
        <div class="axis" data-axis="z" data-type="t">
            <div class="row"><button class="mini btn-z" id="zMinus">Z-</button><input type="range" id="zSlider"
                    min="-200" max="200" value="0" step="1"><button class="mini btn-z" id="zPlus">Z+</button></div>
            <div class="subrow"><button id="zReset">Reset</button><input type="number" id="zInput" min="-200" max="200"
                    step="1" value="0"></div>
        </div>

        <h3>Rotation</h3>
        <div class="axis" data-axis="rx" data-type="r">
            <div class="row"><button class="mini btn-z" id="rxMinus">Z-</button><input type="range" id="rxSlider"
                    min="-180" max="180" value="0" step="1"><button class="mini btn-z" id="rxPlus">Z+</button></div>
            <div class="subrow"><button id="rxReset">Reset</button><input type="number" id="rxInput" min="-180"
                    max="180" step="1" value="0"></div>
        </div>
        <div class="axis" data-axis="ry" data-type="r">
            <div class="row"><button class="mini btn-x" id="ryMinus">X-</button><input type="range" id="rySlider"
                    min="-180" max="180" value="0" step="1"><button class="mini btn-x" id="ryPlus">X+</button></div>
            <div class="subrow"><button id="ryReset">Reset</button><input type="number" id="ryInput" min="-180"
                    max="180" step="1" value="0"></div>
        </div>
        <div class="axis" data-axis="rz" data-type="r">
            <div class="row"><button class="mini btn-y" id="rzMinus">Y-</button><input type="range" id="rzSlider"
                    min="-180" max="180" value="0" step="1"><button class="mini btn-y" id="rzPlus">Y+</button></div>
            <div class="subrow"><button id="rzReset">Reset</button><input type="number" id="rzInput" min="-180"
                    max="180" step="1" value="0"></div>
        </div>
        <div class="vrow"><button id="resetAll">Reset All</button></div>
    </section>

    <!-- Libraries (CDN + local) -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@3.4.0/quaternion.min.js"></script>
    <script src="./stewart.js"></script>

    <script>
        // ---------- State ----------
        let platform;
        let animMgr = null;            // Stewart.Animation instance (RAW-style)
        let pingBall = null;           // pingpong ball state (for draw)
        const position = { x: 0, y: 0, z: 0 };
        const rotation = { rx: 0, ry: 0, rz: 0 }; // deg
        const view = { x: 90, y: 0, z: 0 };       // deg

        let ikClampEnabled = true;
        let ikClampAnimEnabled = true;

        const stepPos = 10, stepRot = 5;

        const opts = {
            rodLength: 130, hornLength: 50, baseRadius: 80, platformRadius: 50,
            anchorDistance: 40, shaftDistance: 30,
            platformTurn: true, hornDirection: false,
            servoRange: [-90 * Math.PI / 180, 90 * Math.PI / 180]
        };

        // Animator UI facade (keeps speed + pattern)
        const animUI = {
            playing: false, pattern: 'none', basePeriod: 3000, pct: 100,
            get period() { return this.basePeriod * (100 / this.pct); },
            start() { this.playing = true; animMgr && animMgr.start(this.patternMap[this.pattern] || this.pattern); syncStartTime(); },
            stop() { this.playing = false; }
        };
        function syncStartTime() { if (!animMgr) return; animMgr.startTime = Date.now(); }

        // ---------- IK status UI ----------
        const ikStatusEl = document.getElementById('ikStatus');
        function setIKStatus(ok, reason = '') {
            ikStatusEl.classList.toggle('bad', !ok);
            ikStatusEl.querySelector('.dot').style.background = ok
                ? getComputedStyle(document.documentElement).getPropertyValue('--ok')
                : getComputedStyle(document.documentElement).getPropertyValue('--bad');
            const label = ok ? 'IK: OK' : `IK: Blocked${reason ? ' — ' + reason : ''}`;
            ikStatusEl.querySelector('span').textContent = label;
            ikStatusEl.title = label; ikStatusEl.setAttribute('aria-label', label);
        }

        // ---------- Extend Stewart.Animation with RAW-style pingpong ----------
        // We graft the controller onto the animation map so it’s started just like RAW does.
        (function addPingPongToStewartAnimation() {
            if (!window.Stewart || !Stewart.Animation || !Stewart.Animation.prototype) return;

            const FN = Stewart.Animation.prototype.fn;

            // Physics constants mirror the RAW pingpong.html controller behavior
            const CTRL = { e: 0.80, Ht: 140, vMax: 800, aMax: 4000, zMin: 0, zMax: 30, tPlan: 0.12, tMin: 0.015, r: 20 };

            FN.pingpong = {
                duration: 0,         // RAW-style “controller” (runs every frame)
                pathVisible: false,
                next: null,
                start: function () {
                    // platform-relative Z stroke state
                    this._pp = {
                        z: 300, dz: 0,   // absolute ball z in world (mm)
                        tPrev: performance.now(),
                        zp: 0, vzp: 0, azp: 0 // platform Z (relative stroke) + derivatives
                    };
                    this.orientation = Quaternion.ONE;
                    this.translation = [0, 0, 0];
                },
                fn: function (_pct, p) {
                    if (!this._pp) this.start();

                    const S = this._pp;
                    const now = performance.now();
                    let dt = (now - S.tPrev) / 1000; S.tPrev = now;
                    // clamp dt to keep stable when tab resumes
                    dt = Math.max(0, Math.min(0.04, dt));

                    // world constants
                    const g = -9.81 * 100; // mm/s^2

                    // Convenience aliases
                    let zp = S.zp, vzp = S.vzp, azp = S.azp;

                    // Predict impact time between ball and paddle plane at (zp + T0[2] + r)
                    const zoff = this.platform.T0 ? this.platform.T0[2] : 0;
                    const paddleTop = zp + zoff + CTRL.r;

                    // Solve 0.5*g*t^2 + dz*t + (z - paddleTop) = 0
                    let tHit = null;
                    {
                        const A = 0.5 * g;
                        const B = S.dz;
                        const C = S.z - paddleTop;
                        const D = B * B - 4 * A * C;
                        if (D >= 0) {
                            const sqrtD = Math.sqrt(D);
                            const t1 = (-B - sqrtD) / (2 * A);
                            const t2 = (-B + sqrtD) / (2 * A);
                            if (t1 > 1e-6) tHit = t1; else if (t2 > 1e-6) tHit = t2;
                        }
                    }

                    // RAW-style planning: near impact, pull paddle towards mid-stroke height
                    if (tHit !== null && tHit < CTRL.tPlan) {
                        const t = Math.max(tHit, CTRL.tMin);
                        const zMid = CTRL.Ht + CTRL.r; // relative to platform plane
                        const w = 12, zeta = 1;
                        azp = (w * w) * (zMid - zp) + (2 * zeta * w) * (0 - vzp);
                        azp = Math.max(-CTRL.aMax, Math.min(CTRL.aMax, azp));
                    } else {
                        // Return paddle to mid stroke between bounces
                        const zMid = 0.5 * (CTRL.zMin + CTRL.zMax);
                        const w = 12, zeta = 1;
                        azp = (w * w) * (zMid - zp) + (2 * zeta * w) * (0 - vzp);
                    }

                    // Integrate paddle Z with limits
                    vzp += azp * dt;
                    vzp = Math.max(-CTRL.vMax, Math.min(CTRL.vMax, vzp));
                    zp += vzp * dt;
                    if (zp > CTRL.zMax) { zp = CTRL.zMax; if (vzp > 0) vzp = 0; }
                    if (zp < CTRL.zMin) { zp = CTRL.zMin; if (vzp < 0) vzp = 0; }

                    // Ball dynamics with gravity
                    S.dz += g * dt;
                    S.z += S.dz * dt;

                    // Contact & restitution (keep the ball up)
                    if (S.z <= (zp + zoff + CTRL.r)) {
                        const vrel = S.dz - vzp;
                        if (vrel < 0) {
                            S.dz = vzp + (-CTRL.e * vrel); // bounce
                        }
                        S.z = zp + zoff + CTRL.r;
                    }

                    // Commit back
                    S.zp = zp; S.vzp = vzp; S.azp = azp;

                    // Controller sets animation translation/orientation RAW-style
                    this.translation = [0, 0, zp];
                    this.orientation = Quaternion.ONE;

                    // Stash for drawing pass (in sketch after platform.draw)
                    this._ppBallZ = S.z;
                }
            };
        })();

        // ---------- p5 sketch ----------
        const sketch = (p) => {
            p.setup = () => {
                const cnv = p.createCanvas(746, 746, p.WEBGL); cnv.parent('canvas');
                p.camera(0, -300, 500, 0, 0, 0, 0, 1, 0);

                // mouse wheel — used by RAW mouse controller; we still capture Z intent for composition
                p.canvas.addEventListener('wheel', (e) => {
                    if (animUI.playing && animUI.pattern === 'mouse') {
                        // RAW mouse uses screen coords in Stewart.Animation, so no wheel Z there;
                        // keep this no-op to avoid fighting RAW.
                        e.preventDefault();
                    }
                }, { passive: true });

                rebuildPlatform();
                const res = isPoseValid(position, rotation); setIKStatus(res.ok, res.reason);
            };

            p.draw = () => {
                p.background(60);
                p.push(); p.translate(0, 100, 0); p.rotateX(view.x * Math.PI / 180); p.rotateY(view.y * Math.PI / 180); p.rotateZ(view.z * Math.PI / 180);

                // Update Stewart.Animation if playing
                if (animUI.playing && animMgr) {
                    // Adjust “duration clock” to honor speed slider by scaling timebase
                    const speedFactor = Math.max(0.1, animUI.pct / 100);
                    // Fake elapsed by compressing/expanding time:
                    // move startTime forward/backward so update() sees scaled passage of time
                    const now = Date.now();
                    // For cyclic patterns with fixed durations:
                    if (animMgr.cur && animMgr.cur.duration > 0) {
                        const elapsed = (now - animMgr.startTime);
                        const scaled = elapsed * speedFactor;
                        animMgr.startTime = now - scaled;
                    }
                    animMgr.update(p); // This also calls platform.update(animT, animQ) internally (RAW behavior)
                }

                // Compose base pose + animation pose (so sliders always offset the loop)
                const aT = animMgr ? animMgr.translation : [0, 0, 0];
                const aQ = animMgr ? animMgr.orientation : Quaternion.ONE;
                const baseQ = Quaternion.fromEuler(rotation.rx * Math.PI / 180, rotation.ry * Math.PI / 180, rotation.rz * Math.PI / 180);
                const finalQ = baseQ.mul(aQ);
                const finalT = [position.x + aT[0], position.y + aT[1], position.z + aT[2]];

                // IK safety for animations (scale back toward base if needed)
                let cand = { x: finalT[0], y: finalT[1], z: finalT[2], rx: rotation.rx, ry: rotation.ry, rz: rotation.rz };
                if (ikClampAnimEnabled && animUI.playing) {
                    const base = { x: position.x, y: position.y, z: position.z, rx: rotation.rx, ry: rotation.ry, rz: rotation.rz };
                    const off = { x: cand.x - base.x, y: cand.y - base.y, z: cand.z - base.z };
                    let lo = 0, hi = 1, ok = isPoseValid(cand, cand).ok;
                    if (!ok) {
                        for (let i = 0; i < 10; i++) {
                            const mid = (lo + hi) * 0.5;
                            const test = { x: base.x + off.x * mid, y: base.y + off.y * mid, z: base.z + off.z * mid, rx: base.rx, ry: base.ry, rz: base.rz };
                            if (isPoseValid(test, test).ok) { lo = mid; cand = test; ok = true; } else { hi = mid; }
                        }
                        if (!ok) cand = base;
                    }
                }

                // Apply & draw
                platform.update([cand.x, cand.y, cand.z], finalQ);
                platform.draw(p);

                // Draw pingpong ball if present
                if (animUI.playing && animUI.pattern === 'pingpong' && animMgr && typeof animMgr._ppBallZ === 'number') {
                    p.push();
                    p.noStroke(); p.fill(255, 220, 80);
                    p.translate(position.x, position.y, animMgr._ppBallZ); // world Z already absolute
                    p.sphere(20);
                    p.pop();
                }

                p.pop();

                // Reflect current animated pose back into the right-side slider UI (for visible dynamics)
                reflectPoseToUI(cand.x, cand.y, cand.z, rotation.rx, rotation.ry, rotation.rz);

                // Final IK indicator
                const res = isPoseValid(cand, cand); setIKStatus(res.ok, res.reason);
            };
        };
        new p5(sketch);

        function rebuildPlatform() {
            platform = new Stewart(); platform.initHexagonal(opts);
            if (Array.isArray(opts.servoRange)) platform.servoRange = opts.servoRange.slice();
            // (Re)create RAW animation manager bound to this platform
            animMgr = new Stewart.Animation(platform);
            pingBall = null;
        }

        // ---------- Helpers ----------
        function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }
        function normDeg(d) { let v = (+d) || 0; while (v > 180) v -= 360; while (v < -180) v += 360; return v; }

        // ---------- Mechanical (LEFT) ----------
        function bindLeft(sliderId, inputId, resetId, key, defVal) {
            const s = document.getElementById(sliderId), n = document.getElementById(inputId), r = document.getElementById(resetId);
            const apply = (v) => { const min = +s.min, max = +s.max; const val = clamp(Math.round(v), min, max); s.value = val; n.value = val; opts[key] = val; rebuildPlatform(); };
            s.oninput = () => apply(+s.value); n.onchange = () => apply(+n.value); r.onclick = () => apply(defVal);
        }
        bindLeft("rodLengthSlider", "rodLengthInput", "rodLengthReset", "rodLength", 130);
        bindLeft("hornLengthSlider", "hornLengthInput", "hornLengthReset", "hornLength", 50);
        bindLeft("baseRadiusSlider", "baseRadiusInput", "baseRadiusReset", "baseRadius", 80);
        bindLeft("platformRadiusSlider", "platformRadiusInput", "platformRadiusReset", "platformRadius", 50);
        bindLeft("anchorDistanceSlider", "anchorDistanceInput", "anchorDistanceReset", "anchorDistance", 40);
        bindLeft("shaftDistanceSlider", "shaftDistanceInput", "shaftDistanceReset", "shaftDistance", 30);
        document.getElementById("platformTurnCheckbox").onchange = e => { opts.platformTurn = e.target.checked; rebuildPlatform(); };
        document.getElementById("hornDirCheckbox").onchange = e => { opts.hornDirection = e.target.checked; rebuildPlatform(); };

        function updateServoRange() {
            const minDeg = parseFloat(document.getElementById("servoMinInput").value) || -90;
            const maxDeg = parseFloat(document.getElementById("servoMaxInput").value) || 90;
            opts.servoRange = [minDeg * Math.PI / 180, maxDeg * Math.PI / 180];
            if (platform) platform.servoRange = opts.servoRange.slice();
        }
        document.getElementById("servoMinInput").onchange = updateServoRange;
        document.getElementById("servoMaxInput").onchange = updateServoRange;
        document.getElementById("servoRangeReset").onclick = () => { document.getElementById("servoMinInput").value = -90; document.getElementById("servoMaxInput").value = 90; updateServoRange(); };

        // ---------- View (LEFT) ----------
        const viewXSlider = document.getElementById('viewXSlider'), viewXInput = document.getElementById('viewXInput');
        const viewYSlider = document.getElementById('viewYSlider'), viewYInput = document.getElementById('viewYInput');
        const viewZSlider = document.getElementById('viewZSlider'), viewZInput = document.getElementById('viewZInput');
        function setViewX(v) { view.x = normDeg(v); viewXSlider.value = view.x; viewXInput.value = view.x; }
        function setViewY(v) { view.y = normDeg(v); viewYSlider.value = view.y; viewYInput.value = view.y; }
        function setViewZ(v) { view.z = normDeg(v); viewZSlider.value = view.z; viewZInput.value = view.z; }
        viewXSlider.oninput = () => setViewX(viewXSlider.value); viewXInput.onchange = () => setViewX(viewXInput.value);
        viewYSlider.oninput = () => setViewY(viewYSlider.value); viewYInput.onchange = () => setViewY(viewYInput.value);
        viewZSlider.oninput = () => setViewZ(viewZSlider.value); viewZInput.onchange = () => setViewZ(viewZInput.value);
        document.getElementById('viewXReset').onclick = () => setViewX(90);
        document.getElementById('viewYReset').onclick = () => setViewY(0);
        document.getElementById('viewZReset').onclick = () => setViewZ(0);

        // ---------- Safety ----------
        document.getElementById("ikClampCheckbox").onchange = e => { ikClampEnabled = e.target.checked; };
        document.getElementById("ikClampAnimCheckbox").onchange = e => { ikClampAnimEnabled = e.target.checked; };

        // ---------- Right panel wiring ----------
        const programmatic = { on: false };
        function flashBlocked(el) { el.classList.remove('blocked'); void el.offsetWidth; el.classList.add('blocked'); }
        function dist3(a, b) { const dx = a[0] - b[0], dy = a[1] - b[1], dz = a[2] - b[2]; return Math.sqrt(dx * dx + dy * dy + dz * dz); }
        function isPoseValid(pos, rot) {
            if (!platform) return { ok: true, reason: '' };
            const prevPos = [position.x, position.y, position.z];
            const prevQ = Quaternion.fromEuler(rotation.rx * Math.PI / 180, rotation.ry * Math.PI / 180, rotation.rz * Math.PI / 180);
            const q = Quaternion.fromEuler((rot.rx || 0) * Math.PI / 180, (rot.ry || 0) * Math.PI / 180, (rot.rz || 0) * Math.PI / 180);
            platform.update([pos.x || 0, pos.y || 0, pos.z || 0], q);
            const angles = platform.getServoAngles && platform.getServoAngles();
            const anglesOK = Array.isArray(angles) && angles.every(a => a !== null);
            let hornsOK = true;
            if (platform.B && platform.H && platform.hornLength) {
                const tol = Math.max(1e-3 * platform.hornLength, 0.5);
                for (let i = 0; i < platform.H.length; i++) {
                    if (dist3(platform.H[i], platform.B[i]) > platform.hornLength + tol) { hornsOK = false; break; }
                }
            }
            platform.update(prevPos, prevQ);
            if (!hornsOK) return { ok: false, reason: 'horn stretch' };
            if (!anglesOK) return { ok: false, reason: 'servo/rod out of range' };
            return { ok: true, reason: '' };
        }

        function connectAxis({ minusBtn, plusBtn, slider, input, resetBtn, obj, key, step }) {
            const s = document.getElementById(slider), i = document.getElementById(input);
            const bMinus = document.getElementById(minusBtn), bPlus = document.getElementById(plusBtn), bReset = document.getElementById(resetBtn);
            const min = +s.min, max = +s.max;
            function attempt(val, sourceEl) {
                val = clamp(Math.round(val), min, max); const prev = obj[key] ?? 0;
                if (ikClampEnabled) {
                    const candPos = { ...position }, candRot = { ...rotation }; if (obj === position) candPos[key] = val; else candRot[key] = val;
                    const res = isPoseValid(candPos, candRot);
                    if (!res.ok) {
                        programmatic.on = true; s.value = prev; i.value = prev; programmatic.on = false;
                        flashBlocked(sourceEl || s); setIKStatus(false, res.reason); return;
                    }
                }
                obj[key] = val; programmatic.on = true; s.value = val; i.value = val; programmatic.on = false;
            }
            bMinus.onclick = () => attempt((obj[key] ?? 0) - step, bMinus);
            bPlus.onclick = () => attempt((obj[key] ?? 0) + step, bPlus);
            bReset.onclick = () => attempt(0, bReset);
            s.oninput = () => { if (!programmatic.on) attempt(+s.value, s); };
            i.onchange = () => { if (!programmatic.on) attempt(+i.value, i); };
        }
        // Translation
        connectAxis({ minusBtn: "xMinus", plusBtn: "xPlus", slider: "xSlider", input: "xInput", resetBtn: "xReset", obj: position, key: "x", step: stepPos });
        connectAxis({ minusBtn: "yMinus", plusBtn: "yPlus", slider: "ySlider", input: "yInput", resetBtn: "yReset", obj: position, key: "y", step: stepPos });
        connectAxis({ minusBtn: "zMinus", plusBtn: "zPlus", slider: "zSlider", input: "zInput", resetBtn: "zReset", obj: position, key: "z", step: stepPos });
        // Rotation
        connectAxis({ minusBtn: "rxMinus", plusBtn: "rxPlus", slider: "rxSlider", input: "rxInput", resetBtn: "rxReset", obj: rotation, key: "rx", step: stepRot });
        connectAxis({ minusBtn: "ryMinus", plusBtn: "ryPlus", slider: "rySlider", input: "ryInput", resetBtn: "ryReset", obj: rotation, key: "ry", step: stepRot });
        connectAxis({ minusBtn: "rzMinus", plusBtn: "rzPlus", slider: "rzSlider", input: "rzInput", resetBtn: "rzReset", obj: rotation, key: "rz", step: stepRot });

        // Reflect pose into sliders while animating (without fighting manual input)
        function reflectPoseToUI(x, y, z, rx, ry, rz) {
            const pairs = [
                ['x', 'xSlider', 'xInput', x], ['y', 'ySlider', 'yInput', y], ['z', 'zSlider', 'zInput', z],
                ['rx', 'rxSlider', 'rxInput', rx], ['ry', 'rySlider', 'ryInput', ry], ['rz', 'rzSlider', 'rzInput', rz],
            ];
            programmatic.on = true;
            for (const [k, sl, inId, val] of pairs) {
                const s = document.getElementById(sl), i = document.getElementById(inId);
                if (!s || !i) continue;
                const clamped = clamp(Math.round(val), +s.min, +s.max);
                s.value = clamped; i.value = clamped;
            }
            programmatic.on = false;
        }

        // ---------- Animation controls ----------
        const patternSel = document.getElementById("animationPatternSelect");
        const speedSlider = document.getElementById("animationSpeedSlider");
        const speedVal = document.getElementById("speedVal");
        const animToggle = document.getElementById("animToggle");

        animUI.patternMap = { // UI -> RAW keys (identical names here)
            wobble: 'wobble', rotate: 'rotate', tilt: 'tilt', helical: 'helical', mouse: 'mouse', gamepad: 'gamepad', pingpong: 'pingpong'
        };

        function setToggleUI(on) {
            animUI.playing = !!on;
            animToggle.setAttribute("aria-pressed", on ? "true" : "false");
            animToggle.classList.toggle("playing", on);
            animToggle.querySelector(".label").textContent = on ? "Pause" : "Play";
        }
        function applySpeed() {
            const pct = Math.max(10, Math.min(300, +speedSlider.value || 100));
            animUI.pct = pct; speedVal.textContent = `${Math.round(pct)}%`;
        }
        speedSlider.oninput = applySpeed; applySpeed();

        function startPattern(name) {
            const allowed = ['wobble', 'pingpong', 'rotate', 'tilt', 'helical', 'mouse', 'gamepad', 'none'];
            animUI.pattern = allowed.includes(name) ? name : 'wobble';
            if (animUI.pattern === 'none') { animUI.stop(); setToggleUI(false); return; }
            animUI.start(); setToggleUI(true);
        }

        animToggle.onclick = () => { if (animUI.playing) { animUI.stop(); setToggleUI(false); } else { startPattern(patternSel.value); } };
        patternSel.onchange = () => { if (animUI.playing) startPattern(patternSel.value); };

        // Keys: play/pause + quick view roll
        document.addEventListener('keydown', (e) => {
            const tag = (document.activeElement && document.activeElement.tagName) || ''; const isTyping = /INPUT|TEXTAREA|SELECT/.test(tag);
            if (!isTyping && e.code === 'Space') { e.preventDefault(); animToggle.click(); }
            if (!isTyping && (e.key === '[' || e.key === ']')) { setViewZ(view.z + (e.key === ']' ? 5 : -5)); }
        });

        // ---------- Global reset ----------
        document.getElementById('resetAll').onclick = () => {
            ['x', 'y', 'z'].forEach(k => position[k] = 0);['rx', 'ry', 'rz'].forEach(k => rotation[k] = 0);
            reflectPoseToUI(0, 0, 0, 0, 0, 0); setViewX(90); setViewY(0); setViewZ(0);
            if (animMgr && animMgr.cur && animMgr.cur.start) animMgr.cur.start.call(animMgr);
        };
    </script>
</body>

</html>